#pragma once

#include <TSim/Module/Module.h>
#include <TSim/Simulation/Testbench.h>
#include <TSim/Pathway/Link.h>
#include <TSim/Pathway/PCIeMessage.h>

#include <cinttypes>
#include <string>
#include <vector>

using namespace std;

// NOTE: this class is for enforcing Link frequency
class PCIeController: public Module
{
private:
    uint32_t PORT_IN;
    uint32_t PORT_OUT;

public:
    PCIeController (string iname, Component *parent, string clkname, PCIeMessage *msgproto)
        : Module ("PCIeController", iname, parent, 1)
    {
        PORT_TX = CreatePort ("tx", Module::PORT_INPUT, msgproto);
        PORT_TX_ext = CreatePort ("tx_ext", Module::PORT_OUTPUT, msgproto);
        PORT_RX_ext = CreatePort ("rx_ext", Module::PORT_INPUT, msgproto);
        PORT_RX = CreatePort ("rx", Module::PORT_OUTPUT, msgproto);

        SetClock (clkname);
    }

    virtual bool IsValidConnection (Port *port, Endpoint *endpt)
    {
        Module::IsValidConnection (port, endpt);

        if ((port->name == "tx_ext" || port->name == "rx_ext") &&
                !dynamic_cast<Link *>(endpt->GetParent()))
        {
            DESIGN_FATAL ("forwarding port must be connected with Link",
                    GetName().c_str());
            return false;
        }

        return true;
    }

    virtual void Operation (Message **inmsgs, Message **outmsgs, 
            const uint32_t *outque_size, Instruction *instr)
    {
        // NOTE: simply forwarding messages
        if (inmsgs[PORT_TX])
        {
            inmsgs[PORT_TX]->Recycle();
            outmsgs[PORT_TX_ext] = inmsgs[PORT_TX];
        }

        if (inmsgs[PORT_RX_ext])
        {
            inmsgs[PORT_RX_ext]->Recycle();
            outmsgs[PORT_RX] = inmsgs[PORT_RX_ext];
        }
    }
};
